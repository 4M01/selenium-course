<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Selenium Practice - Synchronization & Wait Strategies</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            max-width: 1000px;
            margin: 0 auto;
            padding: 20px;
            color: #333;
            background-color: #fef4ff;
        }

        h1,
        h2,
        h3 {
            color: #9c0a9c;
            border-bottom: 2px solid #e83ae8;
            padding-bottom: 8px;
        }

        h1 {
            text-align: center;
            margin-bottom: 30px;
        }

        .method-section,
        .dropdown-section {
            background-color: #fff;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            border: 1px solid #e270e2;
            box-shadow: 0 3px 6px rgba(156, 10, 156, 0.1);
        }

        .form-group {
            margin-bottom: 15px;
        }

        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            color: #9c0a9c;
        }

        input[type="text"],
        input[type="email"],
        input[type="number"],
        textarea,
        select {
            width: 100%;
            padding: 10px;
            border: 1px solid #e270e2;
            border-radius: 4px;
            box-sizing: border-box;
            font-size: 16px;
        }

        input[type="text"]:focus,
        input[type="email"]:focus,
        input[type="number"]:focus,
        textarea:focus,
        select:focus {
            outline: none;
            border-color: #9c0a9c;
            box-shadow: 0 0 5px rgba(156, 10, 156, 0.3);
        }

        input[disabled] {
            background-color: #f8e8fc;
            cursor: not-allowed;
        }

        select[multiple] {
            height: 120px;
        }

        button {
            background-color: #c20cc2;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            margin-top: 10px;
            transition: background-color 0.3s;
        }

        button:hover {
            background-color: #9c0a9c;
        }

        .checkbox-group {
            margin: 10px 0;
        }

        .result {
            background-color: #faeaff;
            padding: 10px;
            border-radius: 4px;
            margin-top: 10px;
            min-height: 20px;
            border: 1px solid #e270e2;
        }

        .hidden {
            display: none;
        }

        .hint {
            font-style: italic;
            color: #9c0a9c;
            font-size: 14px;
            margin-top: 5px;
        }

        .method-info {
            background-color: #faeaff;
            padding: 10px;
            border-radius: 4px;
            margin-bottom: 15px;
            font-size: 14px;
            border: 1px dashed #e270e2;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
            border: 2px solid #e270e2;
        }

        th,
        td {
            padding: 10px;
            text-align: left;
            border: 1px solid #e270e2;
        }

        th {
            background-color: #faeaff;
            color: #9c0a9c;
        }

        .main-tabs {
            display: flex;
            overflow: hidden;
            border: 1px solid #e270e2;
            background-color: #faeaff;
            border-radius: 8px 8px 0 0;
        }

        .main-tabs button {
            flex: 1;
            background-color: inherit;
            border: none;
            outline: none;
            cursor: pointer;
            padding: 14px 16px;
            transition: 0.3s;
            font-size: 16px;
            margin-top: 0;
            border-radius: 0;
            color: #9c0a9c;
        }

        .main-tabs button:hover {
            background-color: #f5d5f5;
        }

        .main-tabs button.active {
            background-color: #c20cc2;
            color: white;
        }

        .main-tabcontent {
            display: none;
            padding: 20px;
            border: 1px solid #e270e2;
            border-top: none;
            border-radius: 0 0 8px 8px;
            animation: fadeEffect 1s;
        }

        .tab {
            overflow: hidden;
            border: 1px solid #e270e2;
            background-color: #faeaff;
            border-radius: 4px 4px 0 0;
            display: flex;
        }

        .tab button {
            flex: 1;
            background-color: inherit;
            border: none;
            outline: none;
            cursor: pointer;
            padding: 10px 16px;
            transition: 0.3s;
            color: #9c0a9c;
            margin-top: 0;
            border-radius: 0;
        }

        .tab button:hover {
            background-color: #f5d5f5;
        }

        .tab button.active {
            background-color: #c20cc2;
            color: white;
        }

        .tabcontent {
            display: none;
            padding: 20px;
            border: 1px solid #e270e2;
            border-top: none;
            border-radius: 0 0 4px 4px;
            animation: fadeEffect 1s;
        }

        .code-block {
            background-color: #faeaff;
            padding: 10px;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            margin: 10px 0;
            overflow-x: auto;
            border: 1px solid #e270e2;
        }

        @keyframes fadeEffect {
            from {
                opacity: 0;
            }

            to {
                opacity: 1;
            }
        }

        footer {
            margin-top: 40px;
            text-align: center;
            color: #9c0a9c;
            font-size: 14px;
            border-top: 2px solid #e83ae8;
            padding-top: 20px;
        }

        a {
            color: #c20cc2;
            text-decoration: none;
        }

        a:hover {
            text-decoration: underline;
        }

        .analogy-box {
            background-color: #faeaff;
            padding: 15px;
            border-radius: 4px;
            margin: 15px 0;
            border: 1px solid #e270e2;
            border-left: 4px solid #c20cc2;
        }

        .analogy-title {
            font-weight: bold;
            color: #9c0a9c;
            margin-bottom: 10px;
            font-size: 1.1rem;
        }

        .pros-cons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }

        .pros,
        .cons {
            padding: 15px;
            border-radius: 4px;
            border: 1px solid #e270e2;
        }

        .pros {
            background-color: #e8f5e8;
            border-left: 4px solid #28a745;
        }

        .cons {
            background-color: #f8e8e8;
            border-left: 4px solid #dc3545;
        }

        .highlight {
            background-color: #fff3cd;
            padding: 10px;
            border-radius: 4px;
            border: 1px solid #ffc107;
            margin: 15px 0;
        }

        .scope-info {
            background-color: #e7f3ff;
            padding: 10px;
            border-radius: 4px;
            margin: 10px 0;
            border: 1px solid #0066cc;
            border-left: 4px solid #0066cc;
        }

        .demo-button {
            background-color: #c20cc2;
            color: white;
            padding: 10px 15px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin: 10px 5px;
            font-size: 14px;
            transition: background-color 0.3s;
        }

        .demo-button:hover {
            background-color: #9c0a9c;
        }

        .demo-button:disabled {
            background-color: #6c757d;
            cursor: not-allowed;
        }

        .slow-element {
            background-color: #28a745;
            color: white;
            padding: 15px;
            margin: 10px 0;
            border-radius: 4px;
            text-align: center;
            font-weight: bold;
            opacity: 0;
            transition: opacity 3s ease;
        }

        .slow-element.show {
            opacity: 1;
        }

        .api-result {
            background-color: #faeaff;
            padding: 15px;
            border-radius: 4px;
            margin: 10px 0;
            border: 1px solid #e270e2;
            min-height: 50px;
        }

        .api-success {
            background-color: #e8f5e8;
            border-left: 4px solid #28a745;
        }

        .api-error {
            background-color: #f8e8e8;
            border-left: 4px solid #dc3545;
        }

        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #c20cc2;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            animation: spin 1s linear infinite;
            display: inline-block;
            margin-right: 10px;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        @media (max-width: 768px) {
            .pros-cons {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>

<body>
    <h1>Selenium Synchronization & Wait Strategies Practice Page</h1>

    <div class="main-tabs">
        <button id="ImplicitWaitTabBtn" class="main-tablinks active"
            onclick="openMainTab(event, 'ImplicitWaitTab')">Implicit Wait</button>
        <button id="ExplicitWaitTabBtn" class="main-tablinks" onclick="openMainTab(event, 'ExplicitWaitTab')">Explicit
            Wait</button>
        <button id="FluentWaitTabBtn" class="main-tablinks" onclick="openMainTab(event, 'FluentWaitTab')">Fluent
            Wait</button>
    </div>

    <!-- Implicit Wait Tab Content -->
    <div id="ImplicitWaitTab" class="main-tabcontent" style="display: block;">
        <h2>Implicit Wait - Global Element Waiting Strategy</h2>

        <div class="method-section">
            <h3>Understanding Implicit Wait</h3>
            <div class="method-info">
                <code>driver.manage().timeouts().implicitlyWait(10, TimeUnit.SECONDS);</code> - Sets a global wait time
                for all element searches.
            </div>

            <div class="scope-info">
                <strong>Scope:</strong> Global - applies to all element searches throughout the entire WebDriver
                session<br>
                <strong>Default Value:</strong> 0 seconds (no wait)
            </div>

            <div class="analogy-box">
                <div class="analogy-title">🏪 Real-Life Analogy: Shopping Mall Elevator</div>
                <p>Imagine you're waiting for an elevator in a busy shopping mall. You press the button and decide:
                    <strong>"I'll wait up to 5 minutes for ANY elevator to arrive."</strong> You don't care which
                    elevator comes first - you'll take the first one that opens. This is exactly how Implicit Wait
                    works!
                </p>
                <p><strong>Key Point:</strong> Once you set this "5-minute rule," it applies to ALL elevators you wait
                    for throughout your entire shopping trip.</p>
            </div>

            <div class="highlight">
                <strong>When to Use:</strong> When your entire application generally takes the same amount of time to
                load elements, and you want a simple, one-time setup.
            </div>

            <div class="pros-cons">
                <div class="pros">
                    <h3>✅ Advantages</h3>
                    <ul>
                        <li>Simple to implement - just one line of code</li>
                        <li>Applies globally to all elements</li>
                        <li>Good for consistent loading times</li>
                        <li>Perfect for beginners</li>
                    </ul>
                </div>
                <div class="cons">
                    <h3>❌ Disadvantages</h3>
                    <ul>
                        <li>Not flexible for different elements</li>
                        <li>Can slow down tests unnecessarily</li>
                        <li>Cannot wait for specific conditions</li>
                        <li>May not work for complex scenarios</li>
                    </ul>
                </div>
            </div>

            <div class="form-group">
                <label>Demo: Implicit Wait Simulation</label>
                <button class="demo-button" onclick="simulateImplicitWait()">Simulate Implicit Wait (10s
                    timeout)</button>
                <div id="implicit-result" class="result"></div>
            </div>
        </div>
    </div>

    <!-- Explicit Wait Tab Content -->
    <div id="ExplicitWaitTab" class="main-tabcontent">
        <h2>Explicit Wait - Condition-Based Waiting Strategy</h2>

        <div class="method-section">
            <h3>Understanding Explicit Wait</h3>
            <div class="method-info">
                <code>WebDriverWait wait = new WebDriverWait(driver, 20);</code><br>
                <code>wait.until(ExpectedConditions.elementToBeClickable(By.id("submit")));</code>
            </div>

            <div class="scope-info">
                <strong>Scope:</strong> Local - applies only to specific elements where explicitly used<br>
                <strong>Default Value:</strong> No default - timeout must be specified when creating WebDriverWait
            </div>

            <div class="analogy-box">
                <div class="analogy-title">👤 Real-Life Analogy: Getting User Profile Data</div>
                <p>You're waiting for someone to create their profile online. You keep checking <strong>"Is their
                        profile
                        complete with name, email, and photo?"</strong> You're not just waiting for time to pass -
                    you're
                    waiting for specific profile data to be available. You check every few seconds until you see all
                    the required information is there!</p>
                <p><strong>Key Point:</strong> You're waiting for SPECIFIC data to appear, not just any element. Perfect
                    for dynamic content loaded via APIs.</p>
            </div>

            <div class="highlight">
                <strong>When to Use:</strong> When you need to wait for specific conditions like element visibility,
                clickability, or text changes. Perfect for dynamic content and AJAX applications.
            </div>

            <div class="method-info">
                <strong>Common ExpectedConditions:</strong><br>
                • <code>elementToBeClickable()</code> - Element is visible and enabled<br>
                • <code>visibilityOfElementLocated()</code> - Element is visible on page<br>
                • <code>presenceOfElementLocated()</code> - Element exists in DOM<br>
                • <code>textToBe()</code> - Element contains specific text<br>
                • <code>titleContains()</code> - Page title contains specific text
            </div>

            <div class="pros-cons">
                <div class="pros">
                    <h3>✅ Advantages</h3>
                    <ul>
                        <li>Waits for specific conditions</li>
                        <li>More efficient than fixed waits</li>
                        <li>Flexible and intelligent</li>
                        <li>Perfect for dynamic content</li>
                    </ul>
                </div>
                <div class="cons">
                    <h3>❌ Disadvantages</h3>
                    <ul>
                        <li>Requires more code setup</li>
                        <li>Need to know what condition to wait for</li>
                        <li>Can be complex for beginners</li>
                        <li>More verbose than implicit wait</li>
                    </ul>
                </div>
            </div>

            <div class="form-group">
                <label>Demo: Explicit Wait with Real Random User API</label>
                <button id="explicit-wait-button" class="demo-button" onclick="simulateExplicitWait()">Simulate Explicit
                    Wait</button>
                <div id="explicit-element" class="api-result">
                    Click the button to fetch random user data and practice explicit wait conditions...
                </div>
            </div>

            <!-- NEW: Explicit Wait vs Quote API (single-source brittleness) -->
            <!-- <div class="form-group">
                <label>Demo: Why Explicit Wait struggles with flaky quote APIs (single source)</label>
                <button id="explicit-quote-button" class="demo-button"
                    onclick="simulateExplicitQuoteWait()">Single‑source Quote (Explicit Wait)</button>
                <div id="explicit-quote-result" class="api-result">
                    This demo calls one quote API and waits for a single condition: “text appears”. If that API hiccups
                    or is slow, the explicit wait times out.
                </div>
                <div class="hint">Tip: Compare this with the Fluent Wait tab, which polls multiple sources and ignores
                    transient errors until a <em>collection</em> goal is met.</div>
            </div> -->
        </div>
    </div>

    <!-- Fluent Wait Tab Content -->
    <div id="FluentWaitTab" class="main-tabcontent">
        <h2>Fluent Wait - Advanced Customizable Waiting Strategy</h2>

        <div class="method-section">
            <h3>Understanding Fluent Wait</h3>
            <div class="method-info">
                <code>FluentWait&lt;WebDriver&gt; wait = new FluentWait&lt;&gt;(driver);  </code><br>
                <code>      wait</code><br>
                <code>              .withTimeout(Duration.ofSeconds(2000))</code><br>
                <code>              .pollingEvery(Duration.ofMillis(2000))</code><br>
                <code>  .ignoring(TimeoutException.class);</code>

            </div>

            <div class="scope-info">
                <strong>Scope:</strong> Local - applies only to specific elements where the FluentWait instance is
                used<br>
                <strong>Default Values:</strong> No defaults - timeout, polling frequency, and exceptions must be
                explicitly configured
            </div>

            <div class="analogy-box">
                <div class="analogy-title">📚 Real-Life Analogy: Collecting Random Quotes</div>
                <p>You're building a collection of inspirational quotes from different sources. You decide:
                    <strong>"I'll
                        spend up to 2 minutes collecting quotes, checking each source every 10 seconds. If one source is
                        temporarily down (error), I'll ignore it and keep trying. But I need at least 3 good quotes
                        before
                        I'm satisfied."</strong>
                </p>
                <p><strong>Key Point:</strong> You have total control over timing, checking frequency, and what
                    failures to ignore while collecting exactly what you need.</p>
            </div>

            <div class="highlight">
                <strong>When to Use:</strong> When you need maximum control over waiting behavior, especially in
                applications with unpredictable loading times or when you need to ignore specific exceptions.
            </div>

            <div class="method-info">
                <strong>Fluent Wait Configuration Options:</strong><br>
                • <code>withTimeout()</code> - Maximum time to wait<br>
                • <code>pollingEvery()</code> - How often to check the condition<br>
                • <code>ignoring()</code> - Which exceptions to ignore<br>
                • <code>withMessage()</code> - Custom error message if condition fails
            </div>

            <div class="pros-cons">
                <div class="pros">
                    <h3>✅ Advantages</h3>
                    <ul>
                        <li>Maximum customization and control</li>
                        <li>Can handle complex scenarios</li>
                        <li>Configurable polling frequency</li>
                        <li>Can ignore specific exceptions</li>
                        <li>Most flexible waiting strategy</li>
                    </ul>
                </div>
                <div class="cons">
                    <h3>❌ Disadvantages</h3>
                    <ul>
                        <li>Most complex to implement</li>
                        <li>Requires more code</li>
                        <li>Can be overkill for simple scenarios</li>
                        <li>Steeper learning curve</li>
                    </ul>
                </div>
            </div>

            <div class="method-section">
                <h3>Single Scenario: proceed with checkout even if the API-backed element misbehaves</h3>
                <div class="highlight">
                    The “Address Widget” below appears only if an API returns data. With a classic explicit wait, a
                    failure
                    blocks the flow.
                    With a fluent wait, we poll, ignore transient errors, and—even if the API never recovers—gracefully
                    fall
                    back to a manual form so the flow continues.
                </div>

                <div class="form-group stack">
                    <div>
                        <label for="pollMs">Polling interval (ms)</label>
                        <input id="pollMs" type="number" min="200" step="100" value="1200" />
                    </div>
                    <div>
                        <label for="maxAttempts">Max attempts</label>
                        <input id="maxAttempts" type="number" min="1" step="1" value="6" />
                    </div>
                    <div class="hint">These mirror <code>pollingEvery()</code> and total timeout in FluentWait.</div>
                </div>

                <div class="form-group">
                    <button class="demo-button" id="btn-explicit" onclick="runExplicitScenario()">Run with Explicit Wait
                        (may block)</button>
                    <button class="demo-button" id="btn-fluent" onclick="runFluentScenario()">Run with Fluent Wait (poll
                        +
                        fallback)</button>
                    <button class="demo-button ghost" id="btn-reset" onclick="resetScenario()">Reset</button>
                </div>

                <div id="scenario-status" class="result">Status: idle</div>

                <div id="address-container" class="api-result">
                    Address Widget area (appears only if API responds)
                </div>

                <div class="form-group">
                    <button id="continue-btn" class="demo-button" disabled>Continue to Payment</button>
                    <span id="flow-badge" class="warn-badge">Blocked</span>
                </div>

                <div class="hint">Teaching purpose: in Selenium, <code>WebDriverWait</code> would wait for “address
                    widget
                    visible”. If it never appears, the test stops. <code>FluentWait</code> lets you poll + ignore
                    <em>exceptions</em> and even proceed via an alternate path.
                </div>
            </div>
        </div>
    </div>

    <footer>
        <p>&copy; 2025 Selenium Synchronization & Wait Strategies Practice Page</p>
        <p>Created for educational purposes. <a href="https://www.selenium.dev/">Selenium Documentation</a></p>
    </footer>

    <script>
        // Function to handle switching between main tabs
        function openMainTab(event, tabName) {
            // Hide all main tab content
            const mainTabContents = document.getElementsByClassName("main-tabcontent");
            for (let i = 0; i < mainTabContents.length; i++) {
                mainTabContents[i].style.display = "none";
            }

            // Remove the 'active' class from all main tab buttons
            const mainTabLinks = document.getElementsByClassName("main-tablinks");
            for (let i = 0; i < mainTabLinks.length; i++) {
                mainTabLinks[i].classList.remove("active");
            }

            // Show the selected tab and add the 'active' class to the clicked button
            document.getElementById(tabName).style.display = "block";
            event.currentTarget.classList.add("active");
        }

        function simulateImplicitWait() {
            const resultDiv = document.getElementById('implicit-result');
            const button = event.target;

            button.disabled = true;
            button.textContent = 'Waiting...';

            resultDiv.innerHTML = '<p style="color: #ffc107;">⏳ Implicit Wait activated: Waiting up to 10 seconds for element...</p>';

            // Simulate finding element after random time (1-8 seconds)
            const findTime = Math.random() * 7000 + 1000;

            setTimeout(() => {
                resultDiv.innerHTML = `
                    <p style="color: #28a745;">✅ Element found after ${(findTime / 1000).toFixed(1)} seconds!</p>
                    <p style="color: #6c757d;">Note: Implicit wait would have waited up to 10 seconds if needed.</p> 
                `;
                button.disabled = false;
                button.textContent = 'Simulate Implicit Wait (10s timeout)';
            }, findTime);
        }

        async function simulateExplicitWait() {
            const resultDiv = document.getElementById('explicit-element');
            const button = event.target;

            button.disabled = true;
            button.textContent = 'Waiting for condition...';
            resultDiv.id = 'textCheck';
            resultDiv.innerHTML = '<div class="spinner"></div><p style="color: #ffc107;">⏳ Explicit Wait: Fetching random user data from API...</p>';
            resultDiv.className = 'api-result';

            try {
                // Fetch from Random User API
                const response = await fetch('https://randomuser.me/api/');
                const data = await response.json();
                const user = data.results[0];

                // Add realistic delay to simulate network/processing time
                await new Promise(resolve => setTimeout(resolve, Math.random() * 2000 + 1500));

                resultDiv.innerHTML = `
                    <div class="api-success">
                        <h4 style="color: #28a745;">✅ Condition met! User data retrieved successfully.</h4>
                        <p><strong>Name:</strong> ${user.name.first} ${user.name.last}</p>
                        <p><strong>Email:</strong> ${user.email}</p>
                        <p><strong>Location:</strong> ${user.location.city}, ${user.location.country}</p>
                        <p><strong>Age:</strong> ${user.dob.age} years old</p>
                        <small style="color: #6c757d;">Explicit wait stopped as soon as the user data was loaded and visible.</small>
                    </div>
                `;
                resultDiv.className = 'api-result api-success';

            } catch (error) {
                resultDiv.innerHTML = `
                    <div class="api-error">
                        <h4 style="color: #dc3545;">❌ API call failed</h4>
                        <p>Error: ${error.message}</p>
                        <small style="color: #6c757d;">Explicit wait would timeout after specified duration.</small>
                    </div>
                `;
                resultDiv.className = 'api-result api-error';
            } finally {
                button.disabled = false;
                button.textContent = 'Simulate Explicit Wait';
            }
        }

        // NEW: Single-source explicit wait for a quote (demonstrates brittleness)
        async function simulateExplicitQuoteWait() {
            const resultDiv = document.getElementById('explicit-quote-result');
            const button = document.getElementById('explicit-quote-button');
            button.disabled = true;
            button.textContent = 'Waiting on single quote source...';
            resultDiv.innerHTML = '<div class="spinner"></div><p style="color: #ffc107;">⏳ Explicit Wait: Asking one quote API for a quote...</p>';
            resultDiv.className = 'api-result';

            // Choose exactly ONE source, and purposely make it flaky to mimic real-world outages
            const realEndpoint = 'https://api.quotable.io/random';
            const badEndpoint = 'https://api.quotable.io/ran' + 'dom-broken'; // guaranteed to fail
            const endpoint = Math.random() < 0.4 ? badEndpoint : realEndpoint; // ~40% failure rate

            // "Explicit wait" style: one condition, one source, fixed timeout
            const timeoutMs = 3000;
            const controller = new AbortController();
            const timer = setTimeout(() => controller.abort(), timeoutMs);

            try {
                const resp = await fetch(endpoint, { signal: controller.signal });
                clearTimeout(timer);
                if (!resp.ok) throw new Error('HTTP ' + resp.status);
                const data = await resp.json();
                const text = data.content || (data.slip && data.slip.advice) || JSON.stringify(data);

                resultDiv.innerHTML = `
                    <div class="api-success">
                        <h4 style="color: #28a745;">✅ Condition met (single source)</h4>
                        <p><strong>Quote:</strong> “${text}”</p>
                        <small style="color: #6c757d;">Explicit wait succeeded because the only source responded in time.</small>
                    </div>
                `;
                resultDiv.className = 'api-result api-success';
            } catch (err) {
                clearTimeout(timer);
                resultDiv.innerHTML = `
                    <div class="api-error">
                        <h4 style="color: #dc3545;">❌ Timeout/Failure (single source)</h4>
                        <p>Reason: ${err.name === 'AbortError' ? 'Request timed out at ' + (timeoutMs / 1000) + 's.' : err.message}</p>
                        <small style="color: #6c757d;">This is the limitation of explicit wait here: one source, one condition. If that source hiccups, you lose.</small>
                    </div>
                `;
                resultDiv.className = 'api-result api-error';
            } finally {
                button.disabled = false;
                button.textContent = 'Single‑source Quote (Explicit Wait)';
            }
        }

        async function simulateFluentWait() {
            const resultDiv = document.getElementById('fluent-result');
            const statusDiv = document.getElementById('fluent-status');
            const button = event.target;

            button.disabled = true;
            button.textContent = 'Fluent Wait in progress...';

            resultDiv.innerHTML = '<div class="spinner"></div><p style="color: #ffc107;">⏳ Fluent Wait: Collecting quotes with custom polling...</p>';
            statusDiv.innerHTML = '';

            const quotes = [];
            let attempts = 0;

            // Read controls
            const pollMsInput = document.getElementById('pollMs');
            const targetQuotesInput = document.getElementById('targetQuotes');
            const maxAttemptsInput = document.getElementById('maxAttempts');

            const pollMs = Math.max(200, parseInt(pollMsInput ? pollMsInput.value : '1500', 10) || 1500);
            const targetQuotes = Math.max(1, parseInt(targetQuotesInput ? targetQuotesInput.value : '3', 10) || 3);
            const maxAttempts = Math.max(1, parseInt(maxAttemptsInput ? maxAttemptsInput.value : '8', 10) || 8);

            // Quote APIs (all free, no key required)
            const quoteAPIs = [
                'https://api.quotable.io/random',
                'https://zenquotes.io/api/random',
                'https://api.adviceslip.com/advice'
            ];

            const pollForQuotes = async () => {
                attempts++;
                statusDiv.innerHTML = `<p style="color: #17a2b8;">🔍 Polling attempt ${attempts}/${maxAttempts} - Collected ${quotes.length}/${targetQuotes} quotes</p>`;

                try {
                    // Randomly select an API; inject some natural flakiness
                    const apiIndex = Math.floor(Math.random() * quoteAPIs.length);
                    let apiUrl = quoteAPIs[apiIndex];
                    if (Math.random() < 0.25) {
                        // 25% chance to use a broken route for this tick to mimic transient failures
                        apiUrl = apiUrl.replace('random', 'rand' + 'om-broken');
                    }

                    const response = await fetch(apiUrl);
                    if (!response.ok) throw new Error('HTTP ' + response.status);
                    const data = await response.json();

                    let quoteText = '';
                    let author = '';

                    // Handle different API response formats
                    if (apiUrl.includes('quotable.io')) {
                        quoteText = data.content;
                        author = data.author;
                    } else if (apiUrl.includes('zenquotes.io')) {
                        // zenquotes returns an array
                        quoteText = (data[0] && data[0].q) || '';
                        author = (data[0] && data[0].a) || 'Unknown';
                    } else if (apiUrl.includes('adviceslip.com')) {
                        quoteText = data.slip && data.slip.advice ? data.slip.advice : '';
                        author = 'Anonymous';
                    }

                    if (quoteText) {
                        quotes.push({ text: quoteText, author: author, source: apiIndex + 1 });
                    }

                    // Success condition: collect N quotes
                    if (quotes.length >= targetQuotes) {
                        resultDiv.innerHTML = `
                            <div class="api-success">
                                <h4 style="color: #28a745;">🎉 Condition satisfied! Collected ${quotes.length} quotes after ${attempts} polling attempts.</h4>
                                ${quotes.map((quote, index) =>
                            `<p><strong>Quote ${index + 1}:</strong> “${quote.text}” — <em>${quote.author}</em> <small>(Source API ${quote.source})</small></p>`
                        ).join('')}
                                <small style="color: #6c757d;">Fluent wait: multiple sources, custom polling, exceptions ignored.</small>
                            </div>
                        `;
                        resultDiv.className = 'api-result api-success';
                        statusDiv.innerHTML = '';
                        button.disabled = false;
                        button.textContent = 'Simulate Fluent Wait';
                        return;
                    }

                } catch (error) {
                    // Fluent wait ignores transient errors and keeps polling
                    statusDiv.innerHTML = `<p style="color: #6c757d;">Ignoring transient failure on attempt ${attempts}: ${error.message}</p>`;
                }

                // Continue polling if we haven't reached max attempts and don't have enough quotes
                if (attempts < maxAttempts) {
                    setTimeout(pollForQuotes, pollMs); // poll according to control
                } else {
                    // Timeout reached
                    if (quotes.length > 0) {
                        resultDiv.innerHTML = `
                            <div class="api-result">
                                <h4 style="color: #ffc107;">⚠️ Partial success! Collected ${quotes.length}/${targetQuotes} quotes after ${maxAttempts} attempts.</h4>
                                ${quotes.map((quote, index) =>
                            `<p><strong>Quote ${index + 1}:</strong> “${quote.text}” — <em>${quote.author}</em></p>`
                        ).join('')}
                                <small style="color: #6c757d;">Fluent wait timed out but still returned useful data.</small>
                            </div>
                        `;
                    } else {
                        resultDiv.innerHTML = `
                            <div class="api-error">
                                <h4 style="color: #dc3545;">❌ Timeout! No quotes collected after ${maxAttempts} polling attempts.</h4>
                                <p>All API calls failed or timed out.</p>
                                <small style="color: #6c757d;">Fluent wait exhausted all polling attempts.</small>
                            </div>
                        `;
                        resultDiv.className = 'api-result api-error';
                    }
                    statusDiv.innerHTML = '';
                    button.disabled = false;
                    button.textContent = 'Simulate Fluent Wait';
                }
            };

            // Start polling
            pollForQuotes();
        }
        // --- Scenario state & helpers ---
        const statusDiv = () => document.getElementById('scenario-status');
        const addrDiv = () => document.getElementById('address-container');
        const contBtn = () => document.getElementById('continue-btn');
        const badge = () => document.getElementById('flow-badge');
        const btnExplicit = () => document.getElementById('btn-explicit');
        const btnFluent = () => document.getElementById('btn-fluent');

        function resetScenario() {
            addrDiv().className = 'api-result';
            addrDiv().innerHTML = 'Address Widget area (appears only if API responds)';
            statusDiv().innerHTML = 'Status: idle';
            contBtn().disabled = true;
            badge().textContent = 'Blocked';
            badge().className = 'warn-badge';
            btnExplicit().disabled = false;
            btnFluent().disabled = false;
        }

        // Mock address API: ~55% success chance per call, 300-1100ms latency
        function mockAddressAPI() {
            return new Promise((resolve, reject) => {
                const latency = 300 + Math.floor(Math.random() * 800);
                setTimeout(() => {
                    const ok = Math.random() < 0.55; // tune for demo clarity
                    if (ok) {
                        resolve({
                            line1: '221B Baker Street',
                            city: 'London',
                            zip: 'NW1 6XE'
                        });
                    } else {
                        reject(new Error('503 Service Unavailable (simulated)'));
                    }
                }, latency);
            });
        }

        function renderWidget(data) {
            addrDiv().className = 'api-result api-success';
            addrDiv().innerHTML = `
        <h4 style="color:#28a745">✅ Address Widget</h4>
        <p><strong>Address:</strong> ${data.line1}, ${data.city} ${data.zip}</p>
        <p class="hint">Backed by API — element is now in the DOM and visible</p>
      `;
        }

        function renderManualFallback() {
            addrDiv().className = 'api-result';
            addrDiv().innerHTML = `
        <h4 style="color:#9c0a9c">📝 Manual Address Entry</h4>
        <div class="form-group"><label>Line 1</label><input type="text" placeholder="Enter address"/></div>
        <div class="form-group"><label>City</label><input type="text" placeholder="Enter city"/></div>
        <div class="form-group"><label>ZIP</label><input type="text" placeholder="Enter ZIP"/></div>
        <a id="manual-address-link" class="hint">This is the fallback path that still lets you continue.</a>
      `;
        }

        // --- Explicit scenario: one wait, one shot, blocks if the element never appears ---
        async function runExplicitScenario() {
            resetScenario();
            btnExplicit().disabled = true;
            btnFluent().disabled = true;
            statusDiv().innerHTML = '<div class="spinner"></div> Explicit Wait: waiting up to 3s for #address-widget to appear…';

            const timeoutMs = 3000;
            let timedOut = false;
            const timer = setTimeout(() => { timedOut = true; }, timeoutMs);

            try {
                const data = await mockAddressAPI();
                if (timedOut) throw new Error('Timeout');
                renderWidget(data);
                statusDiv().innerHTML = '✅ Condition met within 3s: Address widget visible.';
                contBtn().disabled = false;
                badge().textContent = 'Ready';
                badge().className = 'success-badge';
            } catch (err) {
                statusDiv().innerHTML = `❌ Timeout/Failure. Explicit wait cannot proceed because the element never appeared.`;
                addrDiv().className = 'api-result api-error';
                addrDiv().innerHTML = `<h4 style="color:#dc3545">Address Widget not available</h4><p>${timedOut ? 'Timed out at 3s' : err.message}</p>`;
                contBtn().disabled = true;
                badge().textContent = 'Blocked';
                badge().className = 'error-badge';
            } finally {
                clearTimeout(timer);
                btnExplicit().disabled = false;
                btnFluent().disabled = false;
            }
        }

        // --- Fluent scenario: poll + ignore exceptions; fallback if exhausted ---
        async function runFluentScenario() {
            resetScenario();
            btnExplicit().disabled = true;
            btnFluent().disabled = true;

            const pollMs = Math.max(200, parseInt(document.getElementById('pollMs').value || '1200', 10));
            const maxAttempts = Math.max(1, parseInt(document.getElementById('maxAttempts').value || '6', 10));

            let attempts = 0;
            let done = false;

            statusDiv().innerHTML = `🔁 Fluent Wait: polling every ${pollMs}ms, up to ${maxAttempts} attempts.`;

            const tryOnce = async () => {
                attempts++;
                statusDiv().innerHTML = `🔍 Attempt ${attempts}/${maxAttempts}…`;
                try {
                    const data = await mockAddressAPI(); // may throw
                    if (done) return;
                    renderWidget(data);
                    statusDiv().innerHTML = `🎉 Address widget loaded after ${attempts} attempts.`;
                    contBtn().disabled = false;
                    badge().textContent = 'Ready';
                    badge().className = 'success-badge';
                    done = true;
                    btnExplicit().disabled = false;
                    btnFluent().disabled = false;
                } catch (err) {
                    if (attempts < maxAttempts) {
                        statusDiv().innerHTML = `⏳ Transient error ignored: ${err.message}. Retrying in ${pollMs}ms…`;
                        setTimeout(tryOnce, pollMs);
                    } else {
                        renderManualFallback();
                        statusDiv().innerHTML = `⚠️ API never recovered after ${attempts} attempts. Proceeding via fallback (flow continues).`;
                        contBtn().disabled = false;
                        badge().textContent = 'Ready (Fallback)';
                        badge().className = 'warn-badge';
                        btnExplicit().disabled = false;
                        btnFluent().disabled = false;
                        done = true;
                    }
                }
            };

            tryOnce();
        }

        // Initialize
        resetScenario();
    </script>
</body>

</html>